/*
Copyright (c) 2012-2016 Daniel Burke

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
   distribution.
*/
#ifdef __APPLE__
#include <OpenGL/gl3.h>
#else
#include <GL/glew.h>
#endif

#include "version.h"	/* generated by make from git */
#include "main.h"
#include "mesh.h"
#include "shader.h"
#include "text.h"

#include <stdio.h>
#include <string.h>
long long time_start = 0;
float time = 0;

float step = 0.0f;


#include "invert4x4_sse.h"

#include <openvr_capi.h>
//#include <openvr.h>
/*
#ifdef WIN32
extern __declspec(dllimport) bool VR_IsHmdPresent();
extern __declspec(dllimport) bool VR_IsRuntimeInstalled();
extern __declspec(dllimport) intptr_t VR_InitInternal(EVRInitError *peError, EVRApplicationType eType);
extern __declspec(dllimport) bool VR_IsInterfaceVersionValid(const char *pchInterfaceVersion);
extern __declspec(dllimport) intptr_t VR_GetGenericInterface(const char *pchInterfaceVersion, EVRInitError *peError);
#endif
#ifdef __APPLE__
*/
intptr_t VR_InitInternal( EVRInitError *peError, EVRApplicationType eType );
void VR_ShutdownInternal();
int VR_IsHmdPresent();
intptr_t VR_GetGenericInterface( const char *pchInterfaceVersion, EVRInitError *peError );
int VR_IsRuntimeInstalled();
const char * VR_GetVRInitErrorAsSymbol( EVRInitError error );
const char * VR_GetVRInitErrorAsEnglishDescription( EVRInitError error );
//#endif

struct VR_IVRSystem_FnTable * OVR = NULL;
struct VR_IVRCompositor_FnTable * OVRC; 
// k_unMaxTrackedDeviceCount = 16
TrackedDevicePose_t m_rTrackedDevicePose [16];

struct FramebufferDesc
{
	GLuint m_nDepthBufferId;
	GLuint m_nRenderTextureId;
	GLuint m_nRenderFramebufferId;
	GLuint m_nResolveTextureId;
	GLuint m_nResolveFramebufferId;
};
struct FramebufferDesc leftEyeDesc;
struct FramebufferDesc rightEyeDesc;

bool CreateFrameBuffer( int nWidth, int nHeight, struct FramebufferDesc *framebufferDesc );

uint32_t m_nRenderWidth;
uint32_t m_nRenderHeight;
int m_iValidPoseCount;
char m_strPoseClasses[17]; // should never get above 16 - k_unMaxTrackedDeviceCount
char m_rDevClassChar[17];
float m_rmat4DevicePose[16][16]; // first 16 is k_unMax, second is 4x4 matrix
float hmdPose[16];
float eye_left[16];
float eye_right[16];

WF_OBJ * bunny;
IMG * img;
GLSLSHADER *shader;

char* glErrorFbStr(GLenum status)
{

	switch(status) {
	case GL_FRAMEBUFFER_COMPLETE: // 0x8CD5
		return "GL_FRAMEBUFFER_COMPLETE";
	case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: // 0x8CD6
		return "GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
	case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: // 0x8CD7
		return "GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
	case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: // 0x8CDB
		return "GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER";
	case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER: // 0x8CDC
		return "GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER";
	case GL_FRAMEBUFFER_UNSUPPORTED: // 0x8CDD
		return "GL_FRAMEBUFFER_UNSUPPORTED";
	case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: // 0x8D56
		return "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
	default:
		return "Unknown";	
	}
	
}

void ConvertSteamVRMatrixToMatrix4(const struct HmdMatrix34_t in, float * out)
{
	for(int x=0; x<4; x++)
	for(int y=0; y<3; y++)
	{
		out[y+4*x] = in.m[y][x];
	}
	out[3] = 0.0f;
	out[7] = 0.0f;
	out[11] = 0.0f;
	out[15] = 1.0f;
}

//-----------------------------------------------------------------------------
// Purpose: Creates a frame buffer. Returns true if the buffer was set up.
//          Returns false if the setup failed.
//-----------------------------------------------------------------------------
bool CreateFrameBuffer( int nWidth, int nHeight, struct FramebufferDesc *framebufferDesc )
{
	glGenFramebuffers(1, &framebufferDesc->m_nRenderFramebufferId );
	glBindFramebuffer(GL_FRAMEBUFFER, framebufferDesc->m_nRenderFramebufferId);

	glGenRenderbuffers(1, &framebufferDesc->m_nDepthBufferId);
	glBindRenderbuffer(GL_RENDERBUFFER, framebufferDesc->m_nDepthBufferId);
	glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH_COMPONENT, nWidth, nHeight );
	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER,	framebufferDesc->m_nDepthBufferId );

	glGenTextures(1, &framebufferDesc->m_nRenderTextureId );
	glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, framebufferDesc->m_nRenderTextureId );
	glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 4, GL_RGBA8, nWidth, nHeight, GL_TRUE);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, framebufferDesc->m_nRenderTextureId, 0);

	GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
	if (status != GL_FRAMEBUFFER_COMPLETE)
	{
		printf("framebuffer1 creation failed: %s\n", glErrorFbStr(status));
		return 1;
	}

	glGenFramebuffers(1, &framebufferDesc->m_nResolveFramebufferId );
	glBindFramebuffer(GL_FRAMEBUFFER, framebufferDesc->m_nResolveFramebufferId);

	glGenTextures(1, &framebufferDesc->m_nResolveTextureId );
	glBindTexture(GL_TEXTURE_2D, framebufferDesc->m_nResolveTextureId );
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, nWidth, nHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, framebufferDesc->m_nResolveTextureId, 0);

	// check FBO status
	status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
	if (status != GL_FRAMEBUFFER_COMPLETE)
	{
		printf("framebuffer2 creation failed\n");
		return 1;
	}
	printf("Framebuffer creation ok! %d, %d\n", nWidth, nHeight);
	glBindFramebuffer( GL_FRAMEBUFFER, 0 );
	printf("Error = \"%s\"\n", glError(glGetError()));
	return 0;
}



int main_init(int argc, char *argv[])
{
	printf("Version    : %s-%s\n", GIT_TAG, GIT_REV);
	printf("GL Vendor  : %s\n", glGetString(GL_VENDOR) );
	printf("GL Renderer: %s\n", glGetString(GL_RENDERER) );
	printf("GL Version : %s\n", glGetString(GL_VERSION) );
	printf("SL Version : %s\n", glGetString(GL_SHADING_LANGUAGE_VERSION) );
	
	time_start = sys_time();

	printf("About to test for Headset\n");
	
	EVRInitError eError;

	if( VR_IsHmdPresent() )
	{
		printf("VR Headset Present\n");
	}

	printf("not dead yet\n");
	
	if( VR_IsRuntimeInstalled() )
	{
		printf("VR Runtime Installed\n");
	}

	printf("not dead yet\n");
	
	uint32_t vrToken = VR_InitInternal(&eError, EVRApplicationType_VRApplication_Scene);

	switch(eError){
		case EVRInitError_VRInitError_None:
			printf("all good\n");
			break;
		default:
			printf("error = %d\n", eError);
	}
/*
	#ifndef __APPLE__
	if( ! VR_IsInterfaceVersionValid(IVRSystem_Version) )
	{
		printf("VR Version error\n");

	}
#endif
*/
	char fnTableName[128];
	int result1 = sprintf(fnTableName, "FnTable:%s", IVRSystem_Version);

	printf("FNTable: %s\n", fnTableName);
	OVR = (struct VR_IVRSystem_FnTable *)VR_GetGenericInterface(fnTableName, &eError);

	result1 = sprintf(fnTableName, "FnTable:%s", IVRCompositor_Version);
	printf("FNTableC: %s\n", fnTableName);
	OVRC = (struct VR_IVRCompositor_FnTable *)VR_GetGenericInterface(fnTableName, &eError);
	
	if (eError != EVRInitError_VRInitError_None)
		return 1;
	if (OVR == NULL)
		return 1;

	bool result2 = OVR->IsDisplayOnDesktop();

	if (result2)
		printf("Display is on desktop\n");
	else
		printf("Display is NOT on desktop\n");

	OVR->GetRecommendedRenderTargetSize( &m_nRenderWidth, &m_nRenderHeight );
	CreateFrameBuffer( m_nRenderWidth, m_nRenderHeight, &leftEyeDesc );
	CreateFrameBuffer( m_nRenderWidth, m_nRenderHeight, &rightEyeDesc );

	bunny = wf_load("data/stanford-bunny.obj");
//	img = img_load("data/cube_texture.png");
	
//	GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
//	GLfloat mat_shininess[] = { 50.0 };
//	GLfloat light_position[] = { -100.0, -100.0, -100.0, 0.0 };
//	glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
//	glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
//	glEnable(GL_LIGHT0);
//	glLightfv(GL_LIGHT0, GL_POSITION, light_position);	

//	glDisable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);
	glDepthRangef( 0.1f, 30.0f);

	shader = shader_load(
		"data/shaders/vertex.shader",
		"data/shaders/fragment.shader" );
	shader_uniform(shader, "matrix");

	return 0;   // it worked!
}


void main_end(void)
{
//	VR_ShutdownInternal();

}

void hmd_eye_calc(EVREye eye, float * dest)
{
	float near = 0.1f;
	float far = 30.0f;

	// HmdMatrix44_t.m = float[4][4]
	// may be column major?
	struct HmdMatrix44_t matP = OVR->GetProjectionMatrix( eye, near, far );
	struct HmdMatrix34_t matT = OVR->GetEyeToHeadTransform( eye );
	// invert matT
	float tmp[16] = {
		matT.m[0][0], matT.m[1][0], matT.m[2][0], 0.0f,	
		matT.m[0][1], matT.m[1][1], matT.m[2][1], 0.0f,	
		matT.m[0][2], matT.m[1][2], matT.m[2][2], 0.0f,	
		matT.m[0][3], matT.m[1][3], matT.m[2][3], 1.0f,	
	};


//	memcpy(tmp, (float*)matT.m, sizeof(matT));


	float out[16];
	invert4x4(tmp, out);

	float tmpP[16] = {
		matP.m[0][0], matP.m[1][0], matP.m[2][0], matP.m[3][0],
		matP.m[0][1], matP.m[1][1], matP.m[2][1], matP.m[3][1],
		matP.m[0][2], matP.m[1][2], matP.m[2][2], matP.m[3][2],
		matP.m[0][3], matP.m[1][3], matP.m[2][3], matP.m[3][3]
	};

	float mB[16];
	

	mat_mul(mB, out, hmdPose);
	
	mat_mul(dest, tmpP, mB);
//	mat_mul(dest, tmp, mOut);
	
}


void GetHMDMatrices(void)
{
	if(!OVR)return;

	// EVREye_Eye_Left
	// EVREye_Eye_Right
	hmd_eye_calc(EVREye_Eye_Left, eye_left);
	hmd_eye_calc(EVREye_Eye_Right, eye_right);
}

void render(float * matrix)
{
	glUseProgram(shader->prog);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);
	glDepthRangef( 0.1f, 30.0f);

	float trans[16];
	float tmp[16];

	float ident[16];
	float mA[16];
	float mB[16];
	float mC[16];
	float mOut[16];
	
	mat_identity(ident);
	mat_trans(mA, 0.0f, 0.0f, -step);

	mat_mul(mOut, matrix, mA);


	glUniformMatrix4fv(shader->unif[0], 1, GL_FALSE, mOut);
	bunny->draw(bunny);
	glUseProgram(0);
}


void main_loop(void)
{
	
	if(step > 4.0f)
		step = 0.0f;
	else
		step += 0.01;


	glEnable(GL_TEXTURE_2D);
	
	glClearColor(0.3f, 0.0f, 0.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	glClearColor(0.3f, 0.3f, 0.3f, 1.0f);
	
	// Process OpenVR events

	if(!OVR)return;

	struct VREvent_t vre;
	while( OVR->PollNextEvent(&vre, sizeof(vre)) )
	{
		switch(vre.eventType) {
			case EVREventType_VREvent_TrackedDeviceActivated:
				printf("device activated\n");
				break;
			case EVREventType_VREvent_TrackedDeviceDeactivated:
				printf("device deavtivated\n");
				break;
			case EVREventType_VREvent_TrackedDeviceUpdated:
				printf("device updated\n");
				break;
		}
	}
	
	// Process OpenVR Controller			// k_unMaxTrackedDeviceCount = 16
	for( TrackedDeviceIndex_t unDevice = 0; unDevice < 16; unDevice++)
	{
		struct VRControllerState_t state;
		if( OVR->GetControllerState( unDevice, &state, sizeof(state) ) )
		{
		//	printf(" it equals \"%d\"\n", state.ulButtonPressed );
		// it tracks buttons at least
			//printf(" it equals 0?\n");

		}
	}

	// Process HMD Position
	if(OVR)
	{	// UpdateHMDMatrixPose()		// k_unMaxTrackedDeviceCount = 16
		OVRC->WaitGetPoses(m_rTrackedDevicePose, 16, NULL, 0);
		m_iValidPoseCount = 0;
		m_strPoseClasses[0] = 0;
			
		for(int nDevice = 0; nDevice < 16; nDevice++)
		if(m_rTrackedDevicePose[nDevice].bPoseIsValid)
		{
			m_iValidPoseCount++;
			ConvertSteamVRMatrixToMatrix4( m_rTrackedDevicePose[nDevice].mDeviceToAbsoluteTracking, m_rmat4DevicePose[nDevice] );
			if (m_rDevClassChar[nDevice]==0)
			{
				switch (OVR->GetTrackedDeviceClass(nDevice))
				{
				case ETrackedDeviceClass_TrackedDeviceClass_Controller:        m_rDevClassChar[nDevice] = 'C'; break;
				case ETrackedDeviceClass_TrackedDeviceClass_HMD:               m_rDevClassChar[nDevice] = 'H'; break;
				case ETrackedDeviceClass_TrackedDeviceClass_Invalid:           m_rDevClassChar[nDevice] = 'I'; break;
				case ETrackedDeviceClass_TrackedDeviceClass_GenericTracker:    m_rDevClassChar[nDevice] = 'G'; break;
				case ETrackedDeviceClass_TrackedDeviceClass_TrackingReference: m_rDevClassChar[nDevice] = 'T'; break;
				default:                                       m_rDevClassChar[nDevice] = '?'; break;
				}
			}
			m_strPoseClasses[nDevice] += m_rDevClassChar[nDevice];
		}

		if ( m_rTrackedDevicePose[k_unTrackedDeviceIndex_Hmd].bPoseIsValid )
		{
			float m[4][4];
			memcpy(m, m_rmat4DevicePose[k_unTrackedDeviceIndex_Hmd], sizeof(m));
	/*		
			float tmp[16] = {
				m[0][0], m[1][0], m[2][0], m[3][0],
				m[0][1], m[1][1], m[2][1], m[3][1],
				m[0][2], m[1][2], m[2][2], m[3][2],
				m[0][3], m[1][3], m[2][3], m[3][3]
			};			
	*/		invert4x4((const float *)m, hmdPose);
		}
		// Get hmd position matrices

		GetHMDMatrices();

	}

//	glEnable(GL_LIGHTING);
	if(OVR)
	{
		glUseProgram( 0 );

		glEnable( GL_MULTISAMPLE );
		glBindFramebuffer( GL_FRAMEBUFFER, leftEyeDesc.m_nRenderFramebufferId );
		glViewport(0, 0, m_nRenderWidth, m_nRenderHeight );

		// render scene
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		render(eye_left);
		//render finish
		glBindFramebuffer( GL_FRAMEBUFFER, 0 );
		glDisable( GL_MULTISAMPLE );
	
		glBindFramebuffer(GL_READ_FRAMEBUFFER, leftEyeDesc.m_nRenderFramebufferId);
		glBindFramebuffer(GL_DRAW_FRAMEBUFFER, leftEyeDesc.m_nResolveFramebufferId );

		glBlitFramebuffer( 0, 0, m_nRenderWidth, m_nRenderHeight, 0, 0, m_nRenderWidth, m_nRenderHeight, 
			GL_COLOR_BUFFER_BIT, GL_LINEAR );

		glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
		glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0 );

		glEnable( GL_MULTISAMPLE );

		// Right Eye
		glBindFramebuffer( GL_FRAMEBUFFER, rightEyeDesc.m_nRenderFramebufferId );
		glViewport(0, 0, m_nRenderWidth, m_nRenderHeight );
		// render scene
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		render(eye_right);
		
		// render finish
		glBindFramebuffer( GL_FRAMEBUFFER, 0 );

		glDisable( GL_MULTISAMPLE );

		glBindFramebuffer(GL_READ_FRAMEBUFFER, rightEyeDesc.m_nRenderFramebufferId );
		glBindFramebuffer(GL_DRAW_FRAMEBUFFER, rightEyeDesc.m_nResolveFramebufferId );

		glBlitFramebuffer( 0, 0, m_nRenderWidth, m_nRenderHeight, 0, 0, m_nRenderWidth, m_nRenderHeight, 
			GL_COLOR_BUFFER_BIT, GL_LINEAR );

		glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
		glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0 );
	}

//	glDisable(GL_LIGHTING);

	
	// render to HMD
	if(OVR)
	{	// functions from example
		// RenderControllerAxes()
		// RenderStereoTargets()
		// RenderCompanionWindow()
		EVRCompositorError cErr;
		VRTextureBounds_t pBounds = { 0.0f, 0.0f, 1.0f, 1.0f };
		Texture_t leftEyeTexture = {(void*)(uintptr_t)leftEyeDesc.m_nResolveTextureId, ETextureType_TextureType_OpenGL, EColorSpace_ColorSpace_Gamma};
		cErr = OVRC->Submit(EVREye_Eye_Left, &leftEyeTexture, &pBounds, EVRSubmitFlags_Submit_Default);

	
		Texture_t rightEyeTexture = {(void*)(uintptr_t)rightEyeDesc.m_nResolveTextureId, ETextureType_TextureType_OpenGL, EColorSpace_ColorSpace_Gamma};
		cErr = OVRC->Submit(EVREye_Eye_Right, &rightEyeTexture, &pBounds, EVRSubmitFlags_Submit_Default);
		
	}
	

	

	glDisable(GL_DEPTH_TEST);
	glViewport( 0, 0, vid_width, vid_height );

	// render left eye (first half of index array )
	glBindTexture(GL_TEXTURE_2D, leftEyeDesc.m_nResolveTextureId );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
	//glRectf(-0.5f,-0.5f,0.0f,0.0f);
/*	glEnable(GL_TEXTURE_2D);
//	glBegin(GL_POLYGON); 
	glTexCoord2f(0.0f, 0.0f);
	glVertex2f(-0.9f, -0.9f);
	glTexCoord2f(1.0f, 0.0f);
	glVertex2f( 0.0f, -0.9f); 
	glTexCoord2f(1.0f, 1.0f);
	glVertex2f( 0.0f,  0.9f);
	glTexCoord2f(0.0f, 1.0f);
	glVertex2f(-0.9f,  0.9f); 
	glEnd( );
*/
	glBindTexture(GL_TEXTURE_2D, rightEyeDesc.m_nResolveTextureId );
/*	glBegin(GL_POLYGON); 
	glTexCoord2f(0.0f, 0.0f);
	glVertex2f(0.1f, -0.9f);
	glTexCoord2f(1.0f, 0.0f);
	glVertex2f( 0.9f, -0.9f); 
	glTexCoord2f(1.0f, 1.0f);
	glVertex2f( 0.9f,  0.9f);
	glTexCoord2f(0.0f, 1.0f);
	glVertex2f(0.1f,  0.9f); 
	glEnd( );	
*/
	glDisable(GL_TEXTURE_2D);
	glDisable( GL_MULTISAMPLE );

	if(keys[KEY_ESCAPE])
	{
		killme=1;
	}

	time = (float)(sys_time() - time_start)/(float)sys_ticksecond;

	glFinish();

	glFlush();
	glFinish();
}

